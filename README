                    The Ada Microkernel Project (TAMP)

-------------------------------------------------------------------------------
Legal
-------------------------------------------------------------------------------

Copright © 2011, Luke A. Guest & Dave Rees, all rights reserved.

License is GPL v2 until further notice and is subject to change during
development.

-------------------------------------------------------------------------------
Introduction
-------------------------------------------------------------------------------

The aim of this project is to create a simple microkernel using Ada as the
implementation lanaguage.

To get the toolchain built, enter the thirdparty directory, and copy the
config-master.inc file to config.inc, edit config.inc and then run the following
command to build the native toolchain:

  ./build-tools.sh -t native

This will compile and install the latest version of GCC (4.6.0) to the directory
of your choice. With a Debian Squeeze machine, this process takes approximately
2.4GB of disk space.

The toolchain has been built on the following machines:

* Ubuntu 10.4; GNAT/GCC 4.4.3
* Debian Squeeze; GNAT/GCC 4.4.5, GNAT/GPL GCC 4.3.6

You then need to build a target toolchain, here we are targeting ARM:
NB. This process requires approximately 1.2GB free space.

  ./build-tools.sh -t arm-none-eabi

After building the toolchain, you will then require a runtime library for the
board you intend to build TAMP for:

  ./build-rts.sh <boardname>

or

  cd <tamp>/rts
  arm-none-eabi-gnatmake -P gnat.gpr -XBoard=xpresso1769 -v

The current builds of the toolchain can now build the RTS from the GPR file.


-------------------------------------------------------------------------------
Getting started
-------------------------------------------------------------------------------

TAMP uses GCC-4.6 due to the total inability of previous versions to build an
Ada cross compiler, we've still had to hack the main makefile and configure
script to enable this even though AdaCore have apparently fixed this which they
haven't, but it works. So the first thing you will need is a toolchain:

1) Native Toolchain for your host OS
2) Cross Toolchain for the target you want to build TAMP for (i.e. ARM)

cd thirdparty
cp config-master.inc config.inc

Edit config.inc for your enviroment, i.e. installation directory.
For help on commands: ./build-tools.sh --help 

Note: You can use sudo to install as root, but that would create root owned dirs.

By default the native compiler will also run the testsuite.

***********************
**** IMPORTANT!!!! ****
***********************

If you decide to use the SVN GCC tree rather than a snapshot of GCC 4.6, you
will need to update the tree yourself if you want to get a newer revision:

cd src/gcc
svn update

N.B: I've enforced this as using the script to update the tree causes the
patches to be overwritten and the build will fail, not only that, the cross
build will completely destroy the TAMP native build! It is very important
that this is understood!

-------------------------------------------------------------------------------
Dependencies
-------------------------------------------------------------------------------

Building the native compiler will also run the testsuite on GNAT, there is no
flag to turn this on/off yet so you will require the following packages:

  dejagnu, expect, tcl, bison, flex, patch.

-------------------------------------------------------------------------------
Common problems
-------------------------------------------------------------------------------

When building the cross gnattools, if the following error occurs:

  make.adb:7388:07: "Create_Temp_Output_File" is undefined

GNAT is not using the right version of the compiler to build itself! Check
that the native tools have built and installed themselves properly into $TAMP
otherwise the gnatmake found will be the system one and s-os_lib may not
have Create_Temp_Output_File subprogram defined.

-------------------------------------------------------------------------------
Caveats
-------------------------------------------------------------------------------

If you have to build the native compiler again after having built the cross
compilers, you will have to reverse the patches applied as they're incompatible
with native builds:

cd thirdparty/src/gcc (or whichever version of GCC the script is using)
cat ../../patches/gcc-4.6/* |patch -p1 -i -

The script will re-apply them for cross builds.

* gnatlib.patch

  Disables the check for the --disable-libada flag such that the gnattools
  target still provided after configure has run.

* gnatlib2.patch

  Removes the dependency of maybe-all-target-libada from all-gnattools thus
  allowing us to build the gnattools.

* gnatlib3.patch

  Removes the last lines in the ada.install-common target which calls
  install-gnatlib as this isn't required, if this is left in the install fails
  with the following message:

    You must first build the GNAT library: make gnatlib

  which is found in the rule ../stamp-gnatlib-$(RTSDIR) within the
  gcc/ada/gcc-interface/Makefile.

* gnattools.patch & gnattools2.patch

  Adds support for ARM in the gnattools. This would need to be modified for
  other bareboard targets where <target>-<toolname> applies.

* Building libs/apps requires the --RTS=$TAMP_SRC_DIR/rts/boards/<boardname> flag
to be set and passed to gnatmake.


-------------------------------------------------------------------------------
The new patch seems to work!
-------------------------------------------------------------------------------
I've added a 4.6.1 patch that attempts to enable GCC to build fully without
horrible hacks, I have managed to get this to build with no errors. The patch 
is based on the info from [13].

I tested this with the following packages:

gcc-4.6.1 (C, Ada)
binutils-2.21.1a
newlib-1.19.0

Before you try this, make sure there are no arm-none-eabi-* tools in your $PATH

Obviously, you will require the gcc-4.6.1.diff patch applied to GCC.

Even though I mention above in the "common problems" I totally forgot about that
and yes, you do have to build the native GCC first.

Native
------

../../../src/gcc-4.6.1/configure --prefix=$HOME/opt/tamp --enable-multilib --enable-shared --with-gnu-as --with-gnu-ld --enable-languages=c,ada --without-ppl --without-cloog --with-system-zlib --disable-libgomp --without-libffi  --without-libiconv-prefix --disable-libmudflap --disable-nls --disable-libstdcxx-pch  &> ../log.native.gcc.config.txt

make -j4 bootstrap &> ../log.gcc.make.txt
make install &> ../log.gcc.make.install.txt

export PATH=$HOME/opt/tamp/bin:$PATH

Cross
-----

../../../src/binutils-2.21.1/configure --prefix=$HOME/opt/tamp --target=arm-none-eabi --enable-interwork --enable-multilib --disable-nls --disable-shared --disable-threads --with-gcc --with-gnu-as --with-gnu-ld --without-ppl --without-cloog &> ../log.binutils.config.txt

make -j4 &> ../log.binutils.make.txt
make install &> ../log.binutils.make.install.txt

../../../src/gcc-4.6.1/configure --prefix=$HOME/opt/tamp --target=arm-none-eabi --enable-interwork --enable-multilib --with-newlib --disable-nls --disable-shared --disable-threads --disable-lto --with-gnu-as --with-gnu-ld --enable-languages=c --disable-libssp --without-headers --without-ppl --without-cloog &> ../log.gcc1.config.txt

make all-gcc  &> ../log.gcc1.make.txt
make install-gcc &> ../log.gcc1.make.install.txt

../../../src/newlib-1.19.0/configure --prefix=$HOME/opt/tamp --target=arm-none-eabi --enable-interwork --enable-multilib --disable-nls --disable-shared --disable-threads  --with-gnu-as --with-gnu-ld --without-ppl --without-cloog &> ../log.newlib.config.txt

make -j4 &> ../log.newlib.make.txt
make install &> ../log.newlib.make.install.txt

# GCC2

../../../src/gcc-4.6.1/configure --prefix=$HOME/opt/tamp --target=arm-none-eabi --enable-interwork --enable-multilib --with-newlib --disable-nls --disable-shared --disable-threads --disable-lto --with-gnu-as --with-gnu-ld --enable-languages=c,ada --disable-libssp --without-ppl --without-cloog &> ../log.gcc2.config.txt

make -j4 &> ../log.gcc2.make.txt
make install &> ../log.gcc2.make.install.txt

Caveats
-------

The above will build with binutils-2.22, newlib-1.19.0 and gcc-4.6.2, but when
configuring newlib, the following needs to be added to the configure line:

  --disable-newlib-supplied-syscalls

For some reason, this does not build properly without it, yet it works fine for
GCC-4.6.1, odd.

Sample outputs
--------------

$ arm-none-eabi-gnatlink -v

GNATLINK 4.6.1
Copyright (C) 1995-2010, Free Software Foundation, Inc.
Usage: arm-none-eabi-gnatlink switches mainprog.ali [non-Ada-objects] [linker-options]

  mainprog.ali   the ALI file of the main program

  -f    force object file list to be generated
  -g    Compile binder source file with debug information
  -n    Do not compile the binder source file
  -R    Do not use a run_path_option
  -v    verbose mode
  -v -v very verbose mode

  -o nam     Use 'nam' as the name of the executable
  -b target  Compile the binder source to run on target
  -Bdir      Load compiler executables from dir
  --GCC=comp Use comp as the compiler
  --LINK=nam Use 'nam' for the linking rather than 'gcc'

  [non-Ada-objects]  list of non Ada object files
  [linker-options]   other options for the linker

$ arm-none-eabi-gnatls -v

GNATLS 4.6.1
Copyright (C) 1997-2010, Free Software Foundation, Inc.

Source Search Path:
   <Current_Directory>
   /home/laguest/opt/tamp/lib/gcc/arm-none-eabi/4.6.1/adainclude/


Object Search Path:
   <Current_Directory>
   /home/laguest/opt/tamp/lib/gcc/arm-none-eabi/4.6.1/adalib/


Project Search Path:
   <Current_Directory>
   /home/laguest/opt/tamp/lib/gnat/

I think I finally have something to build on.

-------------------------------------------------------------------------------
Bugs
-------------------------------------------------------------------------------

I've submitted the following bug as the compiler cannot create a libgnat.a from
a GPR file, this has to be done via make, it is no longer a blocker:

  http://gcc.gnu.org/bugzilla/show_bug.cgi?id=47717 - CLOSED

Using Long_Long_Integer in a divide generates a call to __aeabi_ldivmod, which
means we could really do with sorting out a proper target build for GNAT so
we don't have to hack it together. This will then build GCC support libs.

-------------------------------------------------------------------------------
TODO
-------------------------------------------------------------------------------

Remove the build-rts.sh and the old patches in thirdparty/patches/gcc-4.6.

Add a check for each tool used, patch, svn, git, bison, flex and exit completely
if they're not available.

Add the options from [6].

Find out how s-hibaen.ads is used, can we use it? In gcc/ada/system.ads there
is a "High_Integrity_Mode" flag which is marked as obsolete. This flag doesn't
exist in the target system specs.

Use SPARK for development?

-------------------------------------------------------------------------------
LPCXpresso1769 JTAG
-------------------------------------------------------------------------------

We need to remove the LPC-Link board from the LPXpresso1769 board. This then
leaves us open for an external JTAG debugger. The following are my notes and
given I know next to nothing about electronics, some help here would be
appreciated.

These are from [5]:

      J4 Xpresso1769 side (page 4: SWD/JTAG Interface)
Pins  Name
 2    VIO_3V3X
 4    JTAG_TMS_SWDIOX
 6    JTAG_TCLK_SWCLKC
 8    JTAG_TDO_SWOX
10    JTAG_TDIX
12    JTAG_RESETX
14    EXT_POWX
16    GNDX

Pin  2 = TRST_N (From page 5: LPC176X Side)
Pin 12 = SRST??

I came to the conclusion that Pin 12 would be the soft reset if pin 2 is
the test reset. Or are these the other way around?

-------------------------------------------------------------------------------
External JTAG interfaces
-------------------------------------------------------------------------------

This section will list various external JTAG debugger's and their pinouts and
we will gradually provide schematics for connecting them to J4 on the
LPCXpresso1769 board.

Opendous-JTAG [7], [10]

Pin	Function  LPCXpresso
0	TDI       10
1	TMS        4
2	TRST      ??
3	SRST      ??
4	TCK        6
5	TDO        8

USBprog [8]

Would this be possible?

FTDI V2DIP1-32 [9]

Would this be possible? Cheap, OpenOCD already works with the FTDI chip. Just
need to know which pins on this board would become with JTAG pins.

From oliver117 (on #Ada - Oliver Kleinke):

J4 pin connections
------------------

 2    VIO_3V3X               Vcc
 4    JTAG_TMS_SWDIOX        TMS
 6    JTAG_TCLK_SWCLKC       TCLK/TCK
 8    JTAG_TDO_SWOX          TDO
10    JTAG_TDIX              TDI
12    JTAG_RESETX            RESET/SRST
14    EXT_POWX               connected to USB power (5V)
16    GNDX                   GND

ARM 10p JTAG
------------

1 Vcc  |  2 TMS
3 GND  |  4 TCK
5 GND  |  6 TDO
7 RTCK |  8 TDI
9 GND  | 10 nRESET/nSRST

=>
ARM JTAG Header -> Board
1 -> 2
2 -> 4
3, 5, 9-> 16
4 -> 6
6 -> 8
7 -> (no RTCK on board, connect to GND)
8 -> 10
10 -> 12
(optional 5v) -> 14

References
----------

http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0184b/I1037757.html

-------------------------------------------------------------------------------
REFERENCES
-------------------------------------------------------------------------------

Cortex-M3:

[1] Cortex™-M3 Technical Reference Manual:
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337i/index.html

[2] ARMv7-M Architecture Reference Manual:
http://infocenter.arm.com/help/topic/com.arm.doc.ddi0403c/index.html

[3] Procedure Call Standard for the ARM Architecture:
http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042d/index.html

[4] Run-time ABI for the ARM architecture:
http://infocenter.arm.com/help/topic/com.arm.doc.ihi0043c/index.html

[5] LPCXpresso1769 schematics:
http://www.embeddedartists.com/sites/default/files/docs/schematics/LPCXpressoLPC1769revB.pdf

[6] Strict Conformance to the ARM:
http://gcc.gnu.org/onlinedocs/gcc-4.6.0/gnat_rm/Strict-Conformance-to-the-Ada-Reference-Manual.html#Strict-Conformance-to-the-Ada-Reference-Manual

[7] Opendous-JTAG:
http://code.google.com/p/opendous-jtag/

[8] USBprog:
http://www2.embedded-projects.net/index.php?page_id=165

[9] FTDI V2DIP1-32:
http://uk.farnell.com/ftdi/v2dip1-32/module-dev-32-pin-1x-usb-vnc2/dp/1825829

[10] eStick:
http://embsys.technikum-wien.at/staff/horauer/estick/estick.php

[11] GNAT Pro User's Guide Supplement for Cross Platforms:
http://www.adacore.com/wp-content/files/auto_update/gnat-cross-docs/html/gnat_ugx.html

[12] GNAT Pro User's Guide Supplement for High-Integrity Edition Platforms:
http://www.adacore.com/wp-content/files/auto_update/gnat-hie-docs/html/gnathie_ug.html

[13] Ada’05 compiler for ARM based systems:
http://www.zsk.p.lodz.pl/~morawski/Dyplomy/Praca%20dyplomowa%20p.%20Horna.pdf
